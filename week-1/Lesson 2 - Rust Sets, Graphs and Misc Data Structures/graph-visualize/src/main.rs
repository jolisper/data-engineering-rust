//! # Reflection Questions:
//!
//! # How does the `rasciigraph` crate generate an ASCII graph?
//!
//! The `rasciigraph` crate generates an ASCII graph by plotting data points
//! onto a grid of characters. Each data point corresponds to a certain
//! character on the graph, based on its value relative to the other data
//! points. The process involves the following steps:
//!
//! - **Scaling**: The data points are scaled to fit within the desired height
//!   of the ASCII graph.
//!
//! - **Mapping**: Each scaled data point is then mapped to a specific row and
//!   column on the grid, where rows correspond to the range of values and
//!   columns to the sequence of data points.
//!
//! - **Character Selection**: For each point on the graph, a character is
//!   selected to represent the data point. This could be a simple character
//!   like an asterisk (*) or a more complex character to improve the visual
//!   resolution of the graph.
//!
//! - **Rendering**: All the characters are rendered in their respective
//!   positions to form the complete ASCII graph.
//!
//! Here is a basic usage example of the `rasciigraph` crate:
//!
//! ```no_run
//! use rasciigraph::plot;
//!
//! fn main() {
//!     let data = vec![0.0, 2.0, 1.0, 4.0, 2.0];
//!     let config = rasciigraph::Config::default();
//!     println!("{}", plot(&data, &config));
//! }
//! ```
//!
//! The output is a simple ASCII representation of the data, which can be
//! printed to the console or integrated into text-based interfaces.
//!
//! # What are the advantages and disadvantages of visualizing data in this way?
//!
//! Visualizing data using ASCII graphs, such as those generated by the
//! `rasciigraph` crate, has several advantages and disadvantages:
//!
//! ## Advantages
//!
//! - **Simplicity**: ASCII graphs are simple to generate and do not require
//!   complex graphics libraries or rendering engines.
//!
//! - **Portability**: They can be displayed on any device that supports basic
//!   text output, including terminals and simple text files, without the need
//!   for graphical support.
//!
//! - **Compatibility**: ASCII graphs are compatible with a wide range of
//!   environments and platforms, from legacy systems to modern terminals.
//!
//! - **Ease of Sharing**: Text-based graphs are easy to share via email or
//!   other text-only communication channels.
//!
//! - **Low Resource Usage**: They consume very little memory and processing
//!   power, making them suitable for low-resource environments.
//!
//! ## Disadvantages
//!
//! - **Limited Resolution**: The resolution of ASCII graphs is limited by the
//!   size of the characters, which can make it difficult to display detailed
//!   data accurately.
//!
//! - **Lack of Interactivity**: Unlike modern graphical visualizations, ASCII
//!   graphs do not support interactive elements like zooming or tooltips.
//!
//! - **Aesthetics**: They are not as visually appealing as graphical
//!   representations, which can be a drawback for presentations or reports.
//!
//! - **Color and Styling Limitations**: ASCII graphs are limited to the colors
//!   and styles supported by the text terminal, which is typically less
//!   versatile than graphical systems.
//!
//! - **Complexity in Representation**: Representing multi-dimensional data or
//!   incorporating multiple data series can be challenging and may result in a
//!   cluttered or confusing output.
//!
//! In conclusion, while ASCII graphs are excellent for simple and quick data
//! visualizations, particularly in text-based environments, they have
//! limitations that make them less suitable for complex or detailed data
//! analysis tasks.
//!
//! # How might you modify this code to visualize a different dataset?
//!
//! To visualize a different dataset using the `rasciigraph` crate, you would
//! need to modify the `data` vector to contain the new dataset values. Here's
//! a step-by-step guide to doing so:
//!
//! 1. **Prepare the New Dataset**: Ensure that the new dataset is in the form
//!    of a `Vec<f64>` or can be converted to this format, as this is what the
//!    `plot` function expects.
//!
//! 2. **Replace the Data Vector**: Substitute the existing `data` vector with
//!    your new dataset.
//!
//! 3. **Adjust Configuration (Optional)**: Modify the `Config` object if you
//!    need to change the graph's configuration, such as setting a different
//!    height, width, or caption for the graph.
//!
//! 4. **Call the `plot` Function**: Use the `plot` function with the new data
//!    and configuration to generate the ASCII graph.
//!
//! Below is an example of how the code can be modified to visualize a different
//! dataset:
//!
//! ```no_run
//! use rasciigraph::{plot, Config};
//!
//! fn main() {
//!     // Replace the original data with the new dataset.
//!     let new_data = vec![3.0, 1.5, 6.0, 8.0, 4.5];
//!
//!     // Optionally, adjust the configuration for the new graph.
//!     let mut config = Config::default();
//!     config.height = 5;
//!     config.width = 30;
//!     config.caption = "New Data Set".to_string();
//!
//!     // Generate and print the ASCII graph for the new dataset.
//!     println!("{}", plot(&new_data, &config));
//! }
//! ```
//!
//! This code will render an ASCII graph representing the new dataset. By
//! following these steps, you can easily adapt the code to visualize any
//! one-dimensional numerical data series.
//!
//! Challenge Questions:
//!
//! # How might you use a graph like this to detect patterns in the data?
//!
//! Utilizing a graph generated by the `rasciigraph` crate can be an effective
//! way to detect patterns within a dataset. Here are the steps and
//! considerations for pattern detection:
//!
//! ## Pattern Recognition Steps
//!
//! 1. **Visual Inspection**: Simply looking at the plotted graph can reveal
//!    obvious trends such as periodicity, spikes, or dips in the data which
//!    might indicate regular or irregular patterns.
//!
//! 2. **Identify Repetitions**: Regular intervals in peaks and troughs can
//!    signify cyclical or repeating patterns which could be seasonal or
//!    time-based.
//!
//! 3. **Look for Anomalies**: Points that deviate significantly from the rest
//!    of the data may indicate outliers or errors.
//!
//! 4. **Compare Segments**: By breaking the graph into segments and comparing
//!    them, you can identify if certain patterns repeat under similar
//!    conditions.
//!
//! 5. **Trend Analysis**: Ascending or descending progressions may reveal
//!    trends over time, such as growth or decline.
//!
//! ## Considerations
//!
//! - **Resolution Limitations**: Since ASCII graphs have limited resolution,
//!   subtle patterns may not be easily identifiable.
//!
//! - **Noise in Data**: Noisy data can obscure patterns, so smoothing or
//!   filtering might be necessary before plotting.
//!
//! - **Scale Sensitivity**: The visual impact of patterns can be affected by
//!   the scale of the graph, so ensure that the scale is appropriate for the
//!   patterns you're trying to detect.
//!
//! - **Contextual Understanding**: Knowledge of the data's context can greatly
//!   aid in pattern recognition, as certain patterns may only make sense within
//!   a specific context.
//!
//! By plotting the data and analyzing the graph with these steps and
//! considerations in mind, one can effectively use ASCII graphs to detect
//! patterns and gain insights into the dataset.
//! 
extern crate rasciigraph;

use rasciigraph::{plot, Config};

fn main() {
    let cities = vec![
        "Lisbon",
        "Madrid",
        "Paris",
        "Berlin",
        "Copenhagen",
        "Stockholm",
        "Moscow",
    ];
    let distances_travelled = vec![0.0, 502.56, 1053.36, 2187.27, 2636.42, 3117.23, 4606.35];

    let city_path = cities.join(" > ");
    println!("{}", city_path);

    println!(
        "{}",
        plot(
            distances_travelled.into_iter().map(|d| d as f64).collect(),
            Config::default()
                .with_offset(10)
                .with_height(10)
                .with_caption("Travelled distances (km)".to_string())
        )
    );

    let cos_vec = coseno_data();
    println!(
        "{}",
        plot(
            cos_vec.into_iter().map(|d| d as f64).collect(),
            Config::default()
                .with_offset(10)
                .with_height(10)
                .with_caption("Coseno".to_string())
        )
    );
}

fn coseno_data() -> Vec<f64> {
    let mut cos_vec = Vec::new();
    for i in 0..=30 {
        cos_vec.push((i as f64).cos());
    }
    cos_vec
}